# 第二次：OOP 面向对象

[toc]

## 面向对象概念

我们在前面已经学习了面向过程编程，也可以自行编写出简单的程序了。我们接着就需要认识面向对象程序设计（Object Oriented Programming）它是我们在Java语言中要学习的重要内容，面向对象也是高级语言的一大重要特性。

## 类与对象

### 类与对象概念

- **对象**：对象是类的一个实例（instance），有**属性**和**行为**。例如，一条狗是一个对象，它的属性有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。
- **类**：类是一个模板，它描述一类对象的行为和状态。

> 所以说，类就是抽象概念的狗，而对象，就是具体的某一条狗。

而我们在Java中，也可以像这样进行编程，我们可以定义一个类，然后进一步创建许多这个类的实例对象。像这种编程方式，我们称为面向对象编程。

### 类与对象的创建 

#### 类的创建

比如现在我们想要定义一个狗类，我们可以右键src目录，点击创建新的类：

![image 20221109155923526](https://s1.ax1x.com/2022/11/13/zFTShR.png)

`我们在对类进行命名时，一般使用英文单词，并且首字母大写，跟变量命名一样，不能出现任何的特殊字符。`

现在我们就创建好了一个类，既然是狗类，那么肯定有狗相关的一些**属性**，接下来我们为这个狗类添加一些相关的属性：

```java
public class Dog {
    //狗的名字
    String name;
    //狗的颜色
    String colour;
    //狗的年龄
    int age;
}
```

可以看见我们是直接将这些属性作为**类的成员变量**定义到类中。

> 一个类可以包含以下类型变量：

>- **局部变量**：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。
>- **成员变量**：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。
>- **类变量**：类变量也声明在类中，方法体之外，但必须声明为 static 类型，也被称为静态变量。

狗除了名字、品种等属性之外还具有吃、叫等行为，接下来我们为这个狗类增加一点行为：

```java
public class Dog {
    //狗的名字
    String name;
    //狗的颜色
    String colour;
    //狗的年龄
    int age;

    void eat() {
    }

    void run() {
    }

    void sleep(){
    }

}
```

可以看见我们是用方法来为这个类增加行为，在上面的例子中：eat()、run()、sleep() 和 name() 都是 Dog 类的方法。这样一个狗类就创建好了。

#### 方法创建与使用 

前面我们介绍了类和对象的定义以及类的创建。那么在我介绍对象的创建和使用之前我们先要了解一下方法的创建和使用。

之前我们说了在定义狗狗的行为的时候，在Dog类中增加了几个方法。

##### 方法的定义

```java
修饰符 返回值类型 方法名(参数类型 参数名){
    ...
    方法体
    ...
    return 返回值;
}
```

- **修饰符：**修饰符，`这是可选的`，告诉编译器如何调用该方法。定义了该方法的访问类型。
- **返回值类型 ：**方法可能会有返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字**void**。
- **方法名：**是方法的实际名称。方法名和参数表共同构成方法签名。
- **参数类型：**参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。
- **方法体：**方法体包含具体的语句，定义该方法的功能。

`TIPS:方法名称同样可以随便起，但是规则跟变量的命名差不多，也是尽量使用小写字母开头的单词，如果是多个单词，一般使用驼峰命名法最规范。`

###### 关于return关键字，我们还需要进行进一步的介绍。

在我们使用return关键字之后，方法就会直接结束并返回结果，所以说在这之后编写的任何代码，都是不可到达的：

![img](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fs2.loli.net%2F2022%2F09%2F19%2FUCcAb9L8lfOzXMZ.png&sign=23195573de37d59c0d283ef1a7b0f2a5d326ebd1daad8ba370463068bce8734f)

在return后编写代码，会导致编译不通过，因为存在不可达语句。如果我们的程序中出现了分支语句，那么必须保证每一个分支都有返回值才可以：

![img](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fs2.loli.net%2F2022%2F09%2F19%2FWjUlRrPwA9EXThV.png&sign=ac6125b7bf07f5a59c19c5fc15af597d9221bd64c00e896c6641a68dc4220025)

只要有任何一个分支缺少了return语句，都无法正常通过编译，总之就是必须考虑到所有的情况，任何情况下都必须要有返回值。

当然，如果方法没有返回值，我们也可以使用return语句，不需要跟上任何内容，只不过这种情况下使用，仅仅是为了快速结束方法的执行。

##### 构造方法

此处我们介绍一个概念构造方法。每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。在**创建一个对象**的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。

```java
public Dog(){
    //无参构造
}

public Dog(String name,String colour,int age){
    //全参构造
    this.name = name;
    this.colour = colour;
    this.age = age;
}
```

###### this关键字

![F2A8BD9C70CD011ED4A3E9D3CFC136AD](https://s1.ax1x.com/2022/11/13/zFT1u8.jpg)

大部分时候，普通方法访问其他方法、成员变量时无须使用 this 前缀，但如果方法里有个局部变量和成员变量同名，但程序又需要在该方法里访问这个被覆盖的成员变量，则必须使用 this 前缀。

#### 对象的创建与使用

##### 对象的创建

对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：

- **声明**：声明一个对象，包括对象名称和对象类型。
- **实例化**：使用关键字 new 来创建一个对象。
- **初始化**：使用 new 创建对象时，会调用构造方法初始化对象。

那么介绍完构造方法后我们就可以正式开始创造自己的小狗狗🐕啦

```java
public class Main {
    public static void main(String[] args) {
        //调用无参构造
       Dog myDog = new Dog();
       //调用有参构造
       Dog myDoggy = new Dog("doggy","orange and white",1);
    }
}
```

只不过这里仅仅是创建出了这样的一个对象，我们目前没有办法去操作这个对象，比如想要修改或是获取这个人的名字等等。既然现在我们知道如何创建对象，那么我们怎么去访问这个对象呢，比如我现在想要去查看或是修改它的名字。

**此时我们可以在Dog类中增加get(),set()方法**

```java
public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public String getColour() {
    return colour;
}

public void setColour(String colour) {
    this.colour = colour;
}

public int getAge() {
    return age;
}

public void setAge(int age) {
    this.age = age;
}
```

这样我们就可以自由的获得和修改你创建的小狗狗的值了，就像这样：

```java
myDoggy.setAge(2);
System.out.println(myDoggy.getAge());
```

##  封装、继承和多态 

封装、继承和多态是面向对象编程的三大特性。

- 封装，把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。

- 继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为。

- 多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的方法。

正是这三大特性，让我们的Java程序更加生动形象。

###  类的封装 

封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要使用Getter和Setter方法来查看和设置变量。

我们可以将之前的Dog类进行改进：

```java
public class Dog {
    //狗的名字
    private String name;
    //狗的颜色
    private String colour;
    //狗的年龄
    private int age;
```

我们甚至还可以将构造方法改成私有的，需要通过我们的内部的方式来构造对象，通过这种方式，我们可以实现单例模式。不过单例模式就不是我们今天的重点，感兴趣的小伙伴可以自己下去了解哦。

封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现，要用什么由类自己来做，不需要外面来操作类内部的东西去完成，封装就是通过访问权限控制来实现的。

![img](https://img-blog.csdn.net/20180702151647232?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4MjAxNTIxNjg1Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

###  类的继承 

前面我们介绍了类的封装，我们接着来看一个非常重要特性：继承。

在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中**非私有**的成员。

比如说我们一开始创建的狗类，根据种类划分，我们可以将这个大类进一步地细分出来，例如：柯基类，柴犬类。实际上这些划分出来的类，本质上还是狗类，也就是说狗类具有的属性，这些划分出来的类同样具有，但是，这些划分出来的类同时也会拥有他们自己独特的技能。

首先创建一个父类：

```java
public class Dog {
    //狗的名字
    private String name;
    //狗的颜色
    private String colour;
    //狗的年龄
    private int age;

    void eat() {
        System.out.println("狗吃");
    }

    void run() {
        System.out.println("狗跑");
    }

    void sleep(){
        System.out.println("狗睡");
    }
```

接着我们可以创建各种各样的子类，想要继承一个类，我们只需要使用extends关键字即可：

```java
public class Corgi extends Dog{
    
}
```

**类的继承可以不断向下，但是同时只能继承一个类，同时，标记为final的类不允许被继承**

当一个类继承另一个类时，属性会被继承，可以直接访问父类中定义的属性，除非父类中将属性的访问权限修改为`private`，那么子类将无法访问（但是依然是继承了这个属性的）。

同样的，在父类中定义的方法同样会被子类继承。子类直接获得了此方法，当我们创建一个子类对象时就可以直接使用这个方法。

是不是感觉非常人性化，子类继承了父类的全部能力，同时还可以[扩展自己的独特能力，就像一句话说的： 龙生龙凤生凤，老鼠儿子会打洞。

```java
Corgi corgi = new Corgi();//在Main函数里创建了一个子类对象
corgi.eat();//此处调用了父类的方法
```

此时控制台打印：狗叫

#### 方法的重写 

此时，我们可以用方法的重写来拓展子类的独特能力。例如我们可以在子类里重写父类的方法：

```java
public class Corgi extends Dog{
    public void eat(){
        System.out.println("Corgi eat");
    }
}
```

那么此时控制台打印为：Corgi eat

- 我们如果**不希望子类重写某个方法**，我们可以在方法前添加**final关键字**，表示这个方法已经是**最终形态**

- 如果父类中方法的可见性为private，那么子类同样无法访问，也就不能重写，但是可以定义同名方法

- 我们在重写父类方法时，如果希望调用父类原本的方法实现，那么同样可以使用`super`关键字：

- 然后就是访问权限的问题，子类在重写父类方法时，不能降低父类方法中的可见性

> 因为子类实际上可以当做父类使用，如果子类的访问权限比父类还低，那么在被当做父类使用时，就可能出现无视访问权限调用的情况，这样肯定是不行的，但是相反的，我们可以在子类中提升权限

##### final关键字

final 在 Java 中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。一旦你将引用声明作 final，你将**不能改变这个引用**了，编译器会检查代码，如果试图将变量再次初始化的话，编译器会报编译错误。

####  抽象

##### 抽象类 

在我们学习了类的继承之后，实际上我们会发现，越是处于顶层定义的类，实际上可以进一步地进行抽象,比如狗类上还有动物类。

在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。

抽象类除了`不能实例化对象`之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。

由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。

父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。

在 Java 语言中使用 abstract class 来定义抽象类。

```Java
public abstract class Dog {
    //狗的名字
    private String name;
    //狗的颜色
    private String colour;
    //狗的年龄
    private int age;

    void eat() {
        System.out.println("狗吃");
    }

    void run() {
        System.out.println("狗跑");
    }

    void sleep(){
        System.out.println("狗睡");
    }
```

此时，之前的Main方法中的对于Dog类的实例化语句就会报错。但是Dog类依旧可以被继承。而且具体的实现，需要由子类来完成

#####  抽象方法

如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。

Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。

抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。

**TIPS:抽象方法的访问权限不能为private**

> 因为抽象方法一定要由子类实现，如果子类都访问不了，那么还有什么意义呢？所以说不能为私有。

##### 抽象类总结规定

-  抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。
-  抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
-  抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
-  构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。
-  抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

#### 方法的重载

上面讲了方法的重写，我们接着来看方法的重载。有些时候，参数类型可能会多种多样，我们的方法需要能够同时应对多种情况：但是要是我们现在不仅要让人类会计算整数，还要会计算小数呢？



![img](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fs2.loli.net%2F2022%2F09%2F20%2Fm7BvM1RctLznhrA.png&sign=ca2d1c2cce0f6150d7ab9d9a71f00a0008f1d5883dffb0fc7139fec265dd7cc7)



当我们使用小数时，可以看到，参数要求的是int类型，那么肯定会出现错误，这个方法只能用于计算整数。此时，为了让这个方法支持使用小数进行计算，我们可以将这个方法进行重载(Overload)。

一个类中可以包含多个同名的方法，但是需要的形式参数不一样，方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！这样就可以正常使用了：

`包括我们之前一直在使用的println方法，其实也是重载了很多次的，因为要支持各种值的打印。`

![img](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fs2.loli.net%2F2022%2F09%2F20%2FN2TRuqEnxrKbpc8.png&sign=472b7a33618662bbe75d75724ead0d70b9215ef2646d67c7c001209879ccc88f)

### 多态

多态是面向对象最重要的特性。你将了解到**多态的实现条件**、**什么是向上转型**以及**什么是向下转型**，并学会使用`instanceof`运算符来检查对象引用是否是类型的实例。

#### 概念和特点

多态顾名思义就是**多种形态**，是指对象能够有多种形态。在面向对象中最常用的多态性发生在当**父类引用指向子类对象**时。在面向对象编程中，所谓多态意指相同的消息给予不同的对象会引发不同的动作。换句话说：多态意味着允许不同类的对象对同一消息做出不同的响应。

例如，火车类和飞机类都继承自交通工具类，这些类下都有各自的`run()`方法，交通工具的`run()`方法输出交通工具可以运输，而火车的`run()`方法输出火车会跑，飞机的`run()`方法则输出飞机会飞，火车和飞机都继承父类的`run()`方法，但是对于不同的对象，拥有不同的操作。

#### 实现多态

##### 实现条件

在 Java 中实现多态有 3 个必要条件：

1. 满足继承关系
2. 要有重写
3. 父类引用指向子类对象

##### 实例

例如，有三个类`Pet`、`Dog`、`Cat`：
父类Pet：

```java
class Pet {
  	// 定义方法 eat
  	public void eat() {
      	System.out.println("宠物吃东西");
    }
}
```

子类Dog继承Pet

```java
class Dog extends Pet { // 继承父类
  	// 重写父类方法 eat
  	public void eat() {
      	System.out.println("狗狗吃狗粮");
    }
}
子类Cat继承Pet
class Cat extends Pet { // 继承父类
  	// 重写父类方法 eat
   	public void eat() {
      	System.out.println("猫猫吃猫粮");
    }
}
```

在代码中，我们看到`Dog`和`Cat`类继承自`Pet`类，并且都重写了其`eat`方法。

现在已经满足了实现多态的前两个条件，那么如何**让父类引用指向子类对象**呢？我们在`main`方法中编写代码：

```java
public void main(String[] args) {
  	// 分别实例化三个对象，并且保持其类型为父类Pet
  	Pet pet = new Pet();
  	Pet dog = new Dog();
  	Pet cat = new Cat();
  	// 调用对象下方法
  	pet.eat();
  	dog.eat();
  	cat.eat();
}
```

运行结果：

```bash
宠物吃东西
狗狗吃狗粮
猫猫吃猫粮
```

在代码中，`Pet dog = new Dog();`、`Pet cat = new Cat();`这两个语句，把`Dog`和`Cat`对象转换为`Pet`对象，这种把一个子类对象转型为父类对象的做法称为**向上转型**。父类引用指向了子类的实例。也就实现了多态。

##### 向上转型

向上转型又称为自动转型、隐式转型。向上转型就是父类引用指向子类实例，也就是子类的对象可以赋值给父类对象。例如：

```java
Pet dog = new Dog();
```

这个是因为`Dog`类继承自`Pet`类，它拥有父类`Pet`的全部功能，所以如果`Pet`类型的变量指向了其子类`Dog`的实例，是不会出现问题的。

向上转型实际上是把一个子类型安全地变成了更加**抽象**的父类型，由于所有类的根类都是`Object`，我们也把子类类型转换为`Object`类型：

```java
Cat cat = new Cat();
Object o = cat;
```

##### 向下转型

向上转型是父类引用指向子类实例，那么如何让**子类引用指向父类实例**呢？使用**向下转型**就可以实现。向下转型也被称为强制类型转换。例如：

```java
// 为Cat类增加run方法
class Cat extends Pet { // 继承父类
  	// 重写父类方法 eat
   	public void eat() {
      	System.out.println("猫猫吃猫粮");
    }
  	
  	public void run() {
      	System.out.println("猫猫跑步");
    }
  
  	public static void main(String[] args) {    	
      	// 实例化子类
      	Pet cat = new Cat();
      	// 强制类型转换，只有转换为Cat对象后，才能调用其下面的run方法
      	Cat catObj = (Cat)cat;
      	catObj.run();
    }
}
```

运行结果：

```bash
猫猫跑步
```

我们为`Cat`类新增了一个`run`方法，此时我们无法通过`Pet`类型的`cat`实例调用到其下面特有的`run`方法，需要向下转型，通过`(Cat)cat`将`Pet`类型的对象强制转换为`Cat`类型，这个时候就可以调用`run`方法了。

使用向下转型的时候，要注意：**不能将父类对象转换为子类类型，也不能将兄弟类对象相互转换**。以下两种都是错误的做法：

```java
// 实例化父类
Pet pet = new Pet();
// 将父类转换为子类
Cat cat = (Cat) pet;

// 实例化Dog类
Dog dog = new Dog();
// 兄弟类转换 ERROR
Cat catObj = (Cat) dog;
```

不能将父类转换为子类，因为子类功能比父类多，多的功能无法凭空变出来。兄弟类之间不能转换，这就更容易理解了，兄弟类之间同样功能不尽相同，不同的功能也无法凭空变出来。

#### instanceof 运算符

`instanceof`运算符用来检查对象引用是否是类型的实例，或者这个类型的子类，并返回布尔值。如果是返回`true`，如果不是返回`false`。通常可以在运行时使用 `instanceof` 运算符指出某个对象是否满足一个特定类型的实例特征。其使用语法为：

```java
<对象引用> instanceof 特定类型
```

例如，在向下转型之前，可以使用`instanceof`运算符判断，这样可以提高向下转型的安全性：

```java
Pet pet = new Cat();
if (pet instanceof Cat) {
		// 将父类转换为子类
		Cat cat = (Cat) pet;
}
```

# 作业

### Level1

> 写一个自己的动物园吧！运用以上讲解的和自己课后自学的关于面向对象的知识点来写一个自己的动物园吧！

`TIPS：可以不按照我的提示创建自己的动物园哦`

**提示**

- 声明一个抽象类`Pet`，封装属性`name`和`sex`，声明一个带有两个参数的构造函数，声明抽象方法`void talk()`和`void eat()`；
- 声明一个`Dog`类继承自`Pet`，封装属性`color`，声明带有三个参数的构造函数，复写`talk()`和`eat()`方法；
- 声明一个`Cat`类继承自`Pet`，封装属性`weight`，声明带有三个参数的构造函数，复写`talk()`和`eat()`方法；
- 编写测试类，通过有参构造函数实例化`Dog`类对象，调用`talk()`方法和`eat()`方法；通过有参构造函数实例化`Cat`类对象 ，调用`talk()`方法和`eat()`方法；
- 在各自的动物子类定义定义一个自己特有的方法



### Level2

> 做一个属于自己的英雄联盟吧（如果有同学没玩过的话，就做个自己熟悉的游戏）
>
> 要求：
>
> - 简单的类的创建，
> - 类的属性可以包括但并不下限于：血量，蓝条，装备，攻击力，防御力，敏捷
> - 将英雄之间的战斗做成回合制游戏，(可以while循环实现)
> - 任何你所想的到的功能，尽可能的花哨
